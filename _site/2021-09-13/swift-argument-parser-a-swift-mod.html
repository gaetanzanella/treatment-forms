<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>SwiftArgumentParser: A Swift mod | Gaétan Zanella</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="SwiftArgumentParser: A Swift mod" />
<meta name="author" content="Gaétan Zanella" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="During the WWDC 2021, Apple promoted for the first time its new SwiftArgumentParser library. It aims to help creating command-line tools in Swift." />
<meta property="og:description" content="During the WWDC 2021, Apple promoted for the first time its new SwiftArgumentParser library. It aims to help creating command-line tools in Swift." />
<link rel="canonical" href="http://localhost:4000/2021-09-13/swift-argument-parser-a-swift-mod" />
<meta property="og:url" content="http://localhost:4000/2021-09-13/swift-argument-parser-a-swift-mod" />
<meta property="og:site_name" content="Gaétan Zanella" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-09-13T00:00:00+02:00" />
<script type="application/ld+json">
{"headline":"SwiftArgumentParser: A Swift mod","url":"http://localhost:4000/2021-09-13/swift-argument-parser-a-swift-mod","datePublished":"2021-09-13T00:00:00+02:00","dateModified":"2021-09-13T00:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2021-09-13/swift-argument-parser-a-swift-mod"},"author":{"@type":"Person","name":"Gaétan Zanella"},"description":"During the WWDC 2021, Apple promoted for the first time its new SwiftArgumentParser library. It aims to help creating command-line tools in Swift.","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
  <link rel="manifest" href="/gaetanzanella.webmanifest">
  <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Gaétan Zanella" />

  <!-- Google Analytics-->
  
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">Gaétan Zanella</h2>
    </a>
    <ul>
      <li><a href="/">Posts</a></li>
      <li><a href="/apps">Apps</a></li>
      <li><a href="/tags">Tags</a></li>
      <li><a href="/archives">Archives</a></li>
      <li><a href="/about">About</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
      
        <a href="https://github.com/gaetanzanella">Gaétan Zanella</a>
      
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2021-09-13 00:00:00 +0200">September 13, 2021</time>
    
  </div>

  <h1 class="post-title">SwiftArgumentParser: A Swift mod</h1>
  <div class="post-line"></div>

  <p>During the WWDC 2021, Apple promoted for the first time its new <a href="https://github.com/apple/swift-argument-parser">SwiftArgumentParser</a> library. It aims to help creating command-line tools in Swift.</p>

<p>In just a few lines of code, we can build a fully documented command-line tool. Like in this example from its tiny (I’m pretty sure they made it tiny on purpose) <a href="https://github.com/apple/swift-argument-parser">README file</a>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">Repeat</span><span class="p">:</span> <span class="kt">ParsableCommand</span> <span class="p">{</span>

    <span class="kd">@Option</span><span class="p">(</span><span class="nv">name</span><span class="p">:</span> <span class="o">.</span><span class="n">shortAndLong</span><span class="p">,</span> <span class="nv">help</span><span class="p">:</span> <span class="s">"The number of times to repeat 'phrase'."</span><span class="p">)</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span><span class="p">?</span>

    <span class="kd">@Argument</span><span class="p">(</span><span class="nv">help</span><span class="p">:</span> <span class="s">"The phrase to repeat."</span><span class="p">)</span>
    <span class="k">var</span> <span class="nv">phrase</span><span class="p">:</span> <span class="kt">String</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">repeatCount</span> <span class="o">=</span> <span class="n">count</span> <span class="p">??</span> <span class="o">.</span><span class="n">max</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="n">repeatCount</span> <span class="p">{</span>
          <span class="nf">print</span><span class="p">(</span><span class="n">phrase</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">Repeat</span><span class="o">.</span><span class="nf">main</span><span class="p">()</span></code></pre></figure>

<p>We express our CLI as a graceful command tree while <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> takes care of all the implementation details: it parses the command-line arguments, instantiates the target command, fulfills its arguments based on their names and finally runs it. It can even generate a built-in help description if a help option is passed:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">$ </span>repeat <span class="nt">--help</span>
USAGE: repeat <span class="o">[</span><span class="nt">--count</span> &lt;count&gt;] &lt;phrase&gt;

ARGUMENTS:
  &lt;phrase&gt;                The phrase to repeat.

OPTIONS:
  <span class="nt">-c</span>, <span class="nt">--count</span> &lt;count&gt;     The number of <span class="nb">times </span>to repeat <span class="s1">'phrase'</span><span class="nb">.</span>
  <span class="nt">-h</span>, <span class="nt">--help</span>              Show <span class="nb">help </span><span class="k">for </span>this command.</code></pre></figure>

<p>Apple brands its library as <strong>straightforward</strong>.</p>

<p>This achievement is big: even if you have never used the library, chances are you can already tell what the code does and how you could use it to create your own CLI command out of it.</p>

<p>Have you ever seen anything as straightfordward in Swift?</p>

<p><code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> should remind you of <code class="language-plaintext highlighter-rouge">SwiftUI</code>. To create a new CLI option, you declare an <code class="language-plaintext highlighter-rouge">@Option</code> property without writing any parsing code. An approach that is similar to the <a href="https://developer.apple.com/xcode/swiftui">declarative syntax</a> of <code class="language-plaintext highlighter-rouge">SwiftUI</code>. In each case, thanks to this high level of abstraction, we only need to state what our code should do rather than writing it explicitly.</p>

<p>However, because Swift’s heavy focus on types, <code class="language-plaintext highlighter-rouge">straightfordwardness</code> is usually not the first quality that comes to mind. Contrary to dynamic languages, such as Ruby, Swift strongly relies on compilation-time validations, making it a safer, but significantly less flexible, language.</p>

<p>In fact, even after pondering on this for a bit, I have no idea how to implement such a behavior using Swift. <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> is not a regular Swift library.</p>

<p>To corroborate, in the previous example, if instead of the <code class="language-plaintext highlighter-rouge">main</code> method, we used the autogenerated empty initializer of <code class="language-plaintext highlighter-rouge">Repeat</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">command</span> <span class="o">=</span> <span class="kt">Repeat</span><span class="p">()</span>
<span class="n">command</span><span class="o">.</span><span class="nf">run</span><span class="p">()</span> <span class="c1">// fatal error</span></code></pre></figure>

<p>This state-of-the-art, Swift library would just… crash! (In this case, <code class="language-plaintext highlighter-rouge">Argument</code> was initialized with only a basic help description, how could <code class="language-plaintext highlighter-rouge">phrase</code> return a string out of it?)</p>

<p>It seems Apple has to bypass some Swift compiler safety checks to offer such an API. It decided to do it even if it could obviously lead to serious codebase issues. Something we, thorough Swift developers, are not used to doing when targeting a production environment. Something we are not used to seeing from Apple.</p>

<p>Starting from this point, I knew the <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> repository would contain some cryptic but powerful Swift usages. I had to deep dive inside it and figure out how Apple managed to make the magic happen.</p>

<h2 id="recreating-the-smallest-swiftargumentparser-api">Recreating the smallest SwiftArgumentParser API</h2>

<p>There are a lot of blogposts out there on how to use <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code>. In this one, I will instead highlight the main implementation tricks Apple used to provide such beautiful API and what is the cost of it.</p>

<p>To that purpose, I developed a basic version of the <a href="https://github.com/apple/swift-argument-parser">library</a> from scratch: <a href="https://github.com/gaetanzanella/FBArgumentParser">FBSwiftArgumentParser</a>.</p>

<p>The library only reproduces the following key features:</p>

<ul>
  <li>An <code class="language-plaintext highlighter-rouge">FBParsableCommand</code> protocol with a <code class="language-plaintext highlighter-rouge">main</code> entry point able to parse the command line arguments and execute the program’s logic.</li>
  <li>An <code class="language-plaintext highlighter-rouge">FBOption</code> String property wrapper to express the String options of the CLI. It supports default values.</li>
  <li>A builtin support for help.</li>
</ul>

<p>Similarly to the <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code>, an example of <code class="language-plaintext highlighter-rouge">FBArgumentParser</code> in a <code class="language-plaintext highlighter-rouge">README</code> file would look like this:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBRepeat</span><span class="p">:</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>

    <span class="kd">@FBOption</span><span class="p">(</span><span class="nv">help</span><span class="p">:</span> <span class="s">"The phrase to repeat."</span><span class="p">)</span>
    <span class="k">var</span> <span class="nv">phrase</span> <span class="o">=</span> <span class="s">"Hello"</span> <span class="c1">// default value 😎</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="mi">2</span> <span class="p">{</span>
          <span class="nf">print</span><span class="p">(</span><span class="n">phrase</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">FBRepeat</span><span class="o">.</span><span class="nf">main</span><span class="p">()</span></code></pre></figure>

<p>And its usage like that:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="o">&gt;</span> fbrepeat <span class="nt">--phrase</span> <span class="s2">"Bonjour"</span>
Bonjour
Bonjour

<span class="o">&gt;</span> fbrepeat
Hello
Hello

<span class="o">&gt;</span> fbrepeat <span class="nt">--help</span>
fbrepeat
<span class="nt">--phrase</span> <span class="o">(</span>optional<span class="o">)</span> <span class="o">(</span>default Hello<span class="o">)</span> The phrase to repeat.</code></pre></figure>

<p>Let’s see how to implement it step by step while keeping it straightforward.</p>

<h2 id="defining-the-main-fbparsablecommand-protocol">Defining the main <code class="language-plaintext highlighter-rouge">FBParsableCommand</code> protocol</h2>

<p>Of course, our implementation starts with the library’s main protocol: <code class="language-plaintext highlighter-rouge">FBParsableCommand</code>.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>
  <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="k">throws</span>
<span class="p">}</span></code></pre></figure>

<p>It is a very basic version of the <code class="language-plaintext highlighter-rouge">ParsableCommand</code>. For example it does not support nesting commands nor contains those fancy properties to customize its help description. But that’s enough for now. As the original one, it will be used by the users of the library to declare their program logic.</p>

<p>We also define the same static <code class="language-plaintext highlighter-rouge">main</code> entry point in an extension (the users are not supposed to override it) as a static method:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">extension</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>

  <span class="kd">static</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// TODO</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The execution steps of the <code class="language-plaintext highlighter-rouge">main</code> method are described in the <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code>’s <code class="language-plaintext highlighter-rouge">README</code> file:</p>

<blockquote>
  <p>You kick off execution by calling your type’s static main() method. The SwiftArgumentParser library parses the command-line arguments (#1), instantiates your command type (#2), and then either executes your run() method or exits with a useful message (#3).</p>
</blockquote>

<p>Let’s write those steps.</p>

<p>First, we create a <code class="language-plaintext highlighter-rouge">FBCommandParser</code> object to encapsulate the command line arguments parsing code.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBCommandParser</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">FBParsableCommand</span><span class="o">.</span><span class="k">Type</span>

    <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">arguments</span> <span class="o">=</span> <span class="nf">parseArguments</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span> <span class="c1">// # 1</span>
        <span class="c1">// TODO #2</span>
    <span class="p">}</span>

    <span class="c1">// creates a dict from the command line arguments:</span>
    <span class="c1">// `command --arg1 "value1" --arg2 "value2"` =&gt; ["arg1": "value1", "arg2": "value2"]</span>
    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">parseArguments</span><span class="p">(</span><span class="n">_</span> <span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">String</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">argumentsToParse</span> <span class="o">=</span> <span class="n">arguments</span>
        <span class="k">var</span> <span class="nv">result</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">String</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>
        <span class="k">while</span> <span class="n">argumentsToParse</span><span class="o">.</span><span class="n">count</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">argument</span> <span class="o">=</span> <span class="n">argumentsToParse</span><span class="o">.</span><span class="nf">removeFirst</span><span class="p">()</span>
            <span class="k">let</span> <span class="nv">isAnArgument</span> <span class="o">=</span> <span class="n">argument</span><span class="o">.</span><span class="nf">starts</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="s">"-"</span><span class="p">)</span> <span class="o">||</span> <span class="n">argument</span><span class="o">.</span><span class="nf">starts</span><span class="p">(</span><span class="nv">with</span><span class="p">:</span> <span class="s">"--"</span><span class="p">)</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">isAnArgument</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="kt">ParsingError</span><span class="o">.</span><span class="n">invalidParameters</span>
            <span class="p">}</span>
            <span class="n">result</span><span class="p">[</span><span class="n">argument</span><span class="o">.</span><span class="nf">replacingOccurrences</span><span class="p">(</span><span class="nv">of</span><span class="p">:</span> <span class="s">"-"</span><span class="p">,</span> <span class="nv">with</span><span class="p">:</span> <span class="s">""</span><span class="p">)]</span> <span class="o">=</span> <span class="n">argumentsToParse</span><span class="o">.</span><span class="nf">removeFirst</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>As we only support CLI option type arguments (“–option value” or “-o value”), we store those key-value arguments in a basic dictionary. We would need something more sophisticated if more argument types were supported, but this will do for now.</p>

<p>Then, we execute the <code class="language-plaintext highlighter-rouge">run</code> method of the created instance and neatly exit the program if an error occured:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">extension</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>

    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">arguments</span> <span class="o">=</span> <span class="kt">CommandLine</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="nf">dropFirst</span><span class="p">()</span> <span class="c1">// we always ignore the first argument</span>
            <span class="k">var</span> <span class="nv">command</span> <span class="o">=</span> <span class="k">try</span> <span class="nf">parseAsRoot</span><span class="p">(</span><span class="kt">Array</span><span class="p">(</span><span class="n">arguments</span><span class="p">))</span> <span class="c1">// #1 #2</span>
            <span class="k">try</span> <span class="n">command</span><span class="o">.</span><span class="nf">run</span><span class="p">()</span> <span class="c1">// #3</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">localizedDescription</span><span class="p">)</span> <span class="c1">// useful message in case of error</span>
            <span class="nf">exit</span><span class="p">(</span><span class="kt">EXIT_FAILURE</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">func</span> <span class="nf">parseAsRoot</span><span class="p">(</span><span class="n">_</span> <span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">parser</span> <span class="o">=</span> <span class="kt">FBCommandParser</span><span class="p">(</span><span class="nv">command</span><span class="p">:</span> <span class="k">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">try</span> <span class="n">parser</span><span class="o">.</span><span class="nf">parse</span><span class="p">(</span><span class="nv">arguments</span><span class="p">:</span> <span class="n">arguments</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We purposedly left a huge <code class="language-plaintext highlighter-rouge">TODO</code> in <code class="language-plaintext highlighter-rouge">FBCommandParser</code>. We basically still have to implement the core of the program: instantiating the target command and filling its properties based on the parsed CLI arguments dictionary.</p>

<h2 id="instantiating-client-commands">Instantiating client commands</h2>

<p><code class="language-plaintext highlighter-rouge">FBParsableCommand</code> obviously needs an initiliazer constraint: <code class="language-plaintext highlighter-rouge">main</code> is a static method and <code class="language-plaintext highlighter-rouge">run</code> an instance one.</p>

<p>Adding a basic <code class="language-plaintext highlighter-rouge">init(arguments: [String])</code> would work from an implementation perspective:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>
  <span class="nf">init</span><span class="p">(</span><span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">String</span><span class="p">])</span>
<span class="p">}</span></code></pre></figure>

<p>But it would require a lot work for the library’s users to implement it. The user would have to manually fulfill its properties based on the given dictionary. Our library should do all the heavy lifting.</p>

<p>This is where <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> shined for the first time. It used a very clever technic:</p>

<blockquote>
  <p>It uses <code class="language-plaintext highlighter-rouge">Decodable</code> to make the compiler generate all the argument parsing code on the client side in one fell swoop</p>
</blockquote>

<p>In fact, if we consider the <code class="language-plaintext highlighter-rouge">[String: String]</code> argument array as a basic formatted data, we can consider <code class="language-plaintext highlighter-rouge">FBParsableCommand</code> as a custom data type. Thus if we can make the <code class="language-plaintext highlighter-rouge">FBParsableCommand</code> inherit from <code class="language-plaintext highlighter-rouge">Decodable</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">FBParsableCommand</span><span class="p">:</span> <span class="kt">Decoding</span> <span class="p">{}</span></code></pre></figure>

<p>All the decoding code can be generated at compilation time right inside the command implementation!</p>

<p>Let’s see it in action:</p>

<p>We first define a basic custom <code class="language-plaintext highlighter-rouge">Decoder</code> object able to return the value associated to the given argument property.</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBOptionsDecoder</span><span class="p">:</span> <span class="kt">Decoder</span> <span class="p">{</span>

  <span class="k">let</span> <span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">String</span><span class="p">]</span>

  <span class="c1">// MARK - Public</span>

  <span class="kd">func</span> <span class="nf">value</span><span class="p">(</span><span class="k">for</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">String</span><span class="p">?)</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">?</span> <span class="p">{</span>
    <span class="n">arguments</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
  <span class="p">}</span>

  <span class="c1">// MARK - Decoder</span>

  <span class="c1">// ...</span>

  <span class="kd">func</span> <span class="n">container</span><span class="o">&lt;</span><span class="kt">Key</span><span class="o">&gt;</span><span class="p">(</span><span class="n">keyedBy</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">Key</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">KeyedDecodingContainer</span><span class="o">&lt;</span><span class="kt">Key</span><span class="o">&gt;</span> <span class="k">where</span> <span class="kt">Key</span> <span class="p">:</span> <span class="kt">CodingKey</span> <span class="p">{</span>
      <span class="k">let</span> <span class="nv">container</span> <span class="o">=</span> <span class="kt">KeyeredArgumentContainer</span><span class="p">(</span><span class="nv">decoder</span><span class="p">:</span> <span class="k">self</span><span class="p">,</span> <span class="nv">type</span><span class="p">:</span> <span class="n">type</span><span class="p">)</span>
      <span class="k">return</span> <span class="kt">KeyedDecodingContainer</span><span class="p">(</span><span class="n">container</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="kt">KeyeredArgumentContainer</span><span class="o">&lt;</span><span class="kt">K</span><span class="p">:</span> <span class="kt">CodingKey</span><span class="o">&gt;</span><span class="p">:</span> <span class="kt">KeyedDecodingContainerProtocol</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">FBOptionsDecoder</span>

    <span class="nf">init</span><span class="p">(</span><span class="nv">decoder</span><span class="p">:</span> <span class="kt">FBOptionsDecoder</span><span class="p">,</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">K</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">decoder</span> <span class="o">=</span> <span class="n">decoder</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>

    <span class="kd">func</span> <span class="n">decode</span><span class="o">&lt;</span><span class="kt">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_</span> <span class="nv">type</span><span class="p">:</span> <span class="kt">T</span><span class="o">.</span><span class="k">Type</span><span class="p">,</span> <span class="n">forKey</span> <span class="nv">key</span><span class="p">:</span> <span class="kt">K</span><span class="p">)</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">T</span> <span class="k">where</span> <span class="kt">T</span><span class="p">:</span> <span class="kt">Decodable</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">value</span><span class="p">(</span><span class="nv">for</span><span class="p">:</span> <span class="n">key</span><span class="o">.</span><span class="n">stringValue</span><span class="p">)</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">element</span> <span class="o">=</span> <span class="n">value</span> <span class="k">as?</span> <span class="kt">T</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">element</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">thow</span> <span class="kt">ParsingError</span><span class="o">.</span><span class="n">missingValue</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>It is almost straightforward as the value associated to a CLI option is already mapped to its name by our <code class="language-plaintext highlighter-rouge">FBCommandParser.parseArguments</code> method. We just need to use the decoding key as a search key in the parsed dictionary.</p>

<p>Then, we can use our custom <code class="language-plaintext highlighter-rouge">Decoder</code> to instanciate the target command, thanks to its conformance to <code class="language-plaintext highlighter-rouge">Decodable</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBCommandParser</span> <span class="p">{</span>

    <span class="kd">enum</span> <span class="kt">ParsingError</span><span class="p">:</span> <span class="kt">Error</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">invalidParameters</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">FBParsableCommand</span><span class="o">.</span><span class="k">Type</span>

    <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">argumentDict</span> <span class="o">=</span> <span class="nf">parseArguments</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">decoder</span> <span class="o">=</span> <span class="kt">FBOptionsDecoder</span><span class="p">(</span><span class="nv">arguments</span><span class="p">:</span> <span class="n">argumentDict</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">try</span> <span class="n">command</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">decoder</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>
<span class="p">}</span></code></pre></figure>

<p>Now, as long as the client command properties implement <code class="language-plaintext highlighter-rouge">Decodable</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBRepeat</span><span class="p">:</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">phrase</span><span class="p">:</span> <span class="kt">String</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="mi">2</span> <span class="p">{</span>
          <span class="nf">print</span><span class="p">(</span><span class="n">phrase</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">FBRepeat</span><span class="o">.</span><span class="nf">main</span><span class="p">()</span></code></pre></figure>

<p>The Swift compiler will <a href="https://developer.apple.com/documentation/foundation/archives_and_serialization/encoding_and_decoding_custom_types">automatically</a> generate the appropriate <code class="language-plaintext highlighter-rouge">Decoder</code> method calls to fulfill all the properties of the target command.</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="o">&gt;</span> fbrepeat <span class="nt">--phrase</span> <span class="s2">"Bonjour"</span>
Bonjour
Bonjour</code></pre></figure>

<p>Notice though that <code class="language-plaintext highlighter-rouge">FBRepeat</code> does not manage default values correctly yet. If we set a default value to a property:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBRepeat</span><span class="p">:</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>

    <span class="k">var</span> <span class="nv">phrase</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Hello"</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="mi">2</span> <span class="p">{</span>
          <span class="nf">print</span><span class="p">(</span><span class="n">phrase</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">FBRepeat</span><span class="o">.</span><span class="nf">main</span><span class="p">()</span></code></pre></figure>

<p>It will be ignored by the generated implementation of the <code class="language-plaintext highlighter-rouge">Decodable</code> protocol:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="o">&gt;</span> fbrepeat
Decoding ERROR</code></pre></figure>

<p>It seems like a small problem but it would force  users to provide a custom implementation of <code class="language-plaintext highlighter-rouge">Decodable</code> in order to add default argument. We do not want that. We need to provide the users with an easy way to customize the decoding of its command.</p>

<p>You’ve guessed it, it is time to introduce property wrappers!</p>

<h2 id="using-property-wrappers-as-argument-descriptions">Using property wrappers as argument descriptions</h2>

<p>In <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> the information that we need to collect from the command line is defined using property wrappers. Each one of them matches to a type of argument (<code class="language-plaintext highlighter-rouge">@Flag</code>, <code class="language-plaintext highlighter-rouge">@Option</code>, <code class="language-plaintext highlighter-rouge">@Argument</code> etc) and provides initiliazers to describe them. We can specify how to parse the argument, its potential default value, its help description etc.</p>

<p>Let’s add a similar declarative API in <code class="language-plaintext highlighter-rouge">FBSwiftArgumentParser</code> and see how we can use it to tweak the parsing behavior.</p>

<p>We start with a basic <code class="language-plaintext highlighter-rouge">FBOption</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">@propertyWrapper</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">FBOption</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="k">var</span> <span class="nv">wrappedValue</span><span class="p">:</span> <span class="kt">String</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">wrappedValue</span> <span class="o">=</span> <span class="s">""</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">wrappedValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">wrappedValue</span> <span class="o">=</span> <span class="n">initialValue</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>It has two public initializers so clients can declare two kinds of arguments:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">FBOption.init(wrappedValue:)</code> describes an optional option with a default value</li>
  <li><code class="language-plaintext highlighter-rouge">FBOption.init()</code> describes a required option</li>
</ul>

<p>Its conformance to <code class="language-plaintext highlighter-rouge">Decodable</code> is straightforward, thanks to <a href="https://developer.apple.com/documentation/swift/decoder/2894882-singlevaluecontainer">singleValueContainer</a>, so we keep the previous benefits provided by the Swift compiler:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">FBOption</span><span class="p">:</span> <span class="kt">Decodable</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">container</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span>
        <span class="n">wrappedValue</span> <span class="o">=</span> <span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">String</span><span class="o">.</span><span class="k">self</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">FBRepeat</span><span class="p">:</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>

    <span class="kd">@FBOption</span>
    <span class="k">var</span> <span class="nv">phrase</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Hello"</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>As expected, our code is still as broken as before though:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="o">&gt;</span> fbrepeat <span class="nt">--phrase</span> <span class="s2">"Bonjour"</span>
Bonjour
Bonjour

<span class="o">&gt;</span> fbrepeat
Decoding ERROR</code></pre></figure>

<p>When no value is specified, <code class="language-plaintext highlighter-rouge">FBCommand.main</code> method still tries to decode the command using <code class="language-plaintext highlighter-rouge">FBOption.init(from:)</code> without being able to provide a proper value for the <code class="language-plaintext highlighter-rouge">phrase</code> argument. The declared default “Hello” value is ignored.</p>

<p>Let’s adapt our parsing code and take into account the potential default values provided by the property wrappers.</p>

<h2 id="the-two-faces-of-the-command-property-wrappers">The two faces of the command property wrappers</h2>

<p>This is probably the most confusing aspect of the implementation.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> property wrappers have two usages depending on their initiliazation</p>
</blockquote>

<p>Because of their declarative interfaces, when decoded, a property wrapper provides a value that can be used by the user during the execution of the command. Otherwise, it only provides a description of itself, used internally, that describes how to decode it.</p>

<p>Let’s highlight those two aspects in <code class="language-plaintext highlighter-rouge">FBOption</code>;</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">init()</code> and <code class="language-plaintext highlighter-rouge">init(wrappedValue:)</code>, used by the library’s clients, produces an <code class="language-plaintext highlighter-rouge">FBOption</code> that describes how to parse its underlying String value</li>
  <li><code class="language-plaintext highlighter-rouge">init(from:)</code>, used internally, produces a decoded <code class="language-plaintext highlighter-rouge">FBOption</code> with a valid wrapped value</li>
</ul>

<p>In code, we can represent the two cases using an enum:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBOptionDefinition</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">isOptional</span><span class="p">:</span> <span class="kt">Bool</span>
    <span class="k">let</span> <span class="nv">defaultValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
<span class="p">}</span>

<span class="kd">@propertyWrapper</span>
<span class="kd">public</span> <span class="kd">struct</span> <span class="kt">FBOption</span> <span class="p">{</span>

    <span class="kd">enum</span> <span class="kt">State</span> <span class="p">{</span>
        <span class="k">case</span> <span class="nf">definition</span><span class="p">(</span><span class="kt">FBOptionDefinition</span><span class="p">)</span>
        <span class="k">case</span> <span class="nf">resolved</span><span class="p">(</span><span class="kt">String</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">private</span> <span class="k">let</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">State</span>
<span class="p">}</span></code></pre></figure>

<p>In the first case, <code class="language-plaintext highlighter-rouge">FBOption</code> only wraps a <code class="language-plaintext highlighter-rouge">FBOptionDefinition</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">extension</span> <span class="kt">FBOption</span>  <span class="p">{</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">initialValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">definition</span><span class="p">(</span><span class="kt">FBOptionDefinition</span><span class="p">(</span><span class="nv">isOptional</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">defaultValue</span><span class="p">:</span> <span class="n">initialValue</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">definition</span><span class="p">(</span><span class="kt">FBOptionDefinition</span><span class="p">(</span><span class="nv">isOptional</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="n">defaultValue</span><span class="p">:</span> <span class="kc">nil</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In the other case, <code class="language-plaintext highlighter-rouge">FBOption</code> stores its actual value:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">extension</span> <span class="kt">FBOption</span><span class="p">:</span> <span class="kt">Decodable</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="n">from</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span><span class="p">)</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">container</span> <span class="o">=</span> <span class="k">try</span> <span class="n">decoder</span><span class="o">.</span><span class="nf">singleValueContainer</span><span class="p">()</span>
        <span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">resolved</span><span class="p">(</span><span class="k">try</span> <span class="n">container</span><span class="o">.</span><span class="nf">decode</span><span class="p">(</span><span class="kt">String</span><span class="o">.</span><span class="k">self</span><span class="p">)))</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>As a result, <code class="language-plaintext highlighter-rouge">FBOption</code> can only return a value if it is decoded:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">FBOption</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="k">var</span> <span class="nv">wrappedValue</span><span class="p">:</span> <span class="kt">String</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">state</span> <span class="p">{</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">definition</span><span class="p">:</span>
                <span class="nf">fatalError</span><span class="p">(</span><span class="s">"FBOption is not decoded"</span><span class="p">)</span>
            <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">resolved</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">value</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This is the issue we faced in the introduction and obviously a tradeoff: <code class="language-plaintext highlighter-rouge">FBOption</code> has two usages but only one non optional public API.</p>

<p>However, as long as the library clients rely on the <code class="language-plaintext highlighter-rouge">main</code> method to execute their program, we can ensure only the autogenerated <code class="language-plaintext highlighter-rouge">Decodable.init(from:)</code> initializer of the parsable command will be used to call the <code class="language-plaintext highlighter-rouge">run</code> method. Thus each property wrappers will be decoded and return a value when the client tries to read a potential CLI option.</p>

<p>Furthermore, when a user declares a command, it now implicitly declares a list of <code class="language-plaintext highlighter-rouge">FBArgumentDefinition</code>:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">Repeat</span><span class="p">:</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>

    <span class="kd">@FBOption</span>
    <span class="k">var</span> <span class="nv">myUsualParameter1</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"Hello"</span> <span class="c1">// uses `FBOption.init(wrappedValue:)` thus it wraps an `FBArgumentDefinition`</span>

    <span class="kd">@FBOption</span>
    <span class="k">var</span> <span class="nv">myUsualParameter2</span><span class="p">:</span> <span class="kt">String</span> <span class="c1">// uses `FBOption.init()` thus it wraps an `FBArgumentDefinition`</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s see how we can use them in our decoding code to ensure the optional values provided will be used when the decoding occurs.</p>

<h2 id="using-property-wrappers-as-reflective-markers">Using property wrappers as reflective markers</h2>

<p>Even if it seems at <a href="https://www.swiftbysundell.com/articles/reflection-in-swift/">odds</a> with its heavy focus on compile-time validation, Swift enables us to inspect, and work with, the members of a type — dynamically, at runtime. It is by using this uncommon capacity of Swift that Apple implemented the decoding of the property wrappers.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> uses metaprogramming</p>
</blockquote>

<p>Let’s see how it works.</p>

<p>We first need a new constraint on the protocol:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">FBParsableCommand</span><span class="p">:</span> <span class="kt">Decodable</span> <span class="p">{</span>
    <span class="nf">init</span><span class="p">()</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="k">throws</span>
<span class="p">}</span></code></pre></figure>

<p>This way, we force the user to provide a way to instantiate a command in a proper definition state, using the definition given by each property’s wrapper.</p>

<p>In fact, we could be confident that the users will only use descriptive wrapper initializers in this case:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">UsualRepeat</span><span class="p">:</span> <span class="kt">ParsableCommand</span> <span class="p">{</span>

    <span class="kd">@FBOption</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">usualProperty</span><span class="p">:</span> <span class="kt">Sting</span>
<span class="p">}</span></code></pre></figure>

<p>Seeing the use of a decoding one, even if it compiles, would be pretty unusual:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="k">let</span> <span class="nv">decoder</span><span class="p">:</span> <span class="kt">Decoder</span> <span class="o">=</span> <span class="o">...</span>

<span class="kd">struct</span> <span class="kt">UnusualRepeat</span><span class="p">:</span> <span class="kt">ParsableCommand</span> <span class="p">{</span>

    <span class="kd">@FBOption</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">decoder</span><span class="p">)</span> <span class="c1">// compiles, but unexpected, and will crash</span>
    <span class="k">var</span> <span class="nv">unusualProperty</span><span class="p">:</span> <span class="kt">Sting</span>
<span class="p">}</span></code></pre></figure>

<p>Thanks to this assumption, as long as the user respects the contract, by instanciating a blank version of the target command, we can use <code class="language-plaintext highlighter-rouge">FBOption</code> as a reflective marker and retrieve all its argument definitions:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">private</span> <span class="kd">extension</span> <span class="kt">FBOption</span> <span class="p">{</span>

    <span class="kd">func</span> <span class="nf">definition</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">FBOptionDefinition</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="n">state</span> <span class="p">{</span>
            <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">definition</span><span class="p">(</span><span class="n">definition</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">definition</span>
            <span class="k">case</span> <span class="o">.</span><span class="nv">resolved</span><span class="p">:</span>
                <span class="nf">fatalError</span><span class="p">(</span><span class="s">"FBOption is already decoded"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kd">extension</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>

    <span class="c1">// extracts all the argument definitions from the command type using mirroring</span>
    <span class="kd">static</span> <span class="kd">func</span> <span class="nf">argumentDefinitions</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">FBOptionDefinition</span><span class="p">]</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">definitionByKey</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">FBOptionDefinition</span><span class="p">]</span> <span class="o">=</span> <span class="p">[:]</span>
        <span class="k">let</span> <span class="nv">blankInstance</span> <span class="o">=</span> <span class="k">Self</span><span class="o">.</span><span class="nf">init</span><span class="p">()</span>
        <span class="kt">Mirror</span><span class="p">(</span><span class="nv">reflecting</span><span class="p">:</span> <span class="n">blankInstance</span><span class="p">)</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">child</span> <span class="k">in</span>
            <span class="k">guard</span> <span class="k">let</span> <span class="nv">codingKey</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="k">let</span> <span class="nv">definition</span> <span class="o">=</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">value</span> <span class="k">as?</span> <span class="kt">FBOption</span><span class="p">)?</span><span class="o">.</span><span class="nf">definition</span><span class="p">()</span> <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
            <span class="c1">// property wrappers are prefixed with "_"</span>
            <span class="k">let</span> <span class="nv">sanitizedCodingKey</span> <span class="o">=</span> <span class="kt">String</span><span class="p">(</span><span class="n">codingKey</span><span class="o">.</span><span class="n">first</span> <span class="o">==</span> <span class="s">"_"</span> <span class="p">?</span> <span class="n">codingKey</span><span class="o">.</span><span class="nf">dropFirst</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">:</span> <span class="n">codingKey</span><span class="o">.</span><span class="nf">dropFirst</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">definitionByKey</span><span class="p">[</span><span class="n">sanitizedCodingKey</span><span class="p">]</span> <span class="o">=</span> <span class="n">definition</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">definitionByKey</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Notice that we need to parse the property wrapper names to match them with their corresponding key, each property wrapper starts with an underscore prefix.</p>

<p>We can now easily retrieve all the potential default values of a command with their corresponding arguments:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBCommandParser</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">FBParsableCommand</span><span class="o">.</span><span class="k">Type</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">defaultParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">:</span> <span class="kt">String</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">command</span><span class="o">.</span><span class="nf">argumentDefinitions</span><span class="p">()</span><span class="o">.</span><span class="n">compactMapValues</span> <span class="p">{</span> <span class="nv">$0</span><span class="o">.</span><span class="n">defaultValue</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>By merging them with the initial CLI arguments dictionary, we can thus easily fill the potential gaps when initializing the target command, using this time its <code class="language-plaintext highlighter-rouge">Decoding.init(from:)</code> initializer:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBCommandParser</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">FBParsableCommand</span><span class="o">.</span><span class="k">Type</span>

    <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">argumentDict</span> <span class="o">=</span> <span class="nf">parseArguments</span><span class="p">(</span><span class="n">arguments</span><span class="p">)</span>
        <span class="n">argumentDict</span><span class="o">.</span><span class="nf">merge</span><span class="p">(</span><span class="nf">defaultParameters</span><span class="p">())</span> <span class="p">{</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="k">in</span> <span class="n">left</span> <span class="p">}</span> <span class="c1">// merging</span>
        <span class="k">let</span> <span class="nv">decoder</span> <span class="o">=</span> <span class="kt">FBOptionsDecoder</span><span class="p">(</span><span class="nv">arguments</span><span class="p">:</span> <span class="n">argumentDict</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">try</span> <span class="n">command</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">decoder</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Thus when an optional option is used:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBRepeat</span><span class="p">:</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>

    <span class="kd">@FBOption</span>
    <span class="k">var</span> <span class="nv">requiredPhrase</span><span class="p">:</span> <span class="kt">String</span>

    <span class="kd">@FBOption</span>
    <span class="k">var</span> <span class="nv">optionalPhrase</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"hello"</span>

    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">1</span><span class="o">...</span><span class="mi">2</span> <span class="p">{</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">requiredPhrase</span><span class="p">)</span>
            <span class="nf">print</span><span class="p">(</span><span class="n">optionalPhrase</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">FBRepeat</span><span class="o">.</span><span class="nf">main</span><span class="p">()</span></code></pre></figure>

<p>The <code class="language-plaintext highlighter-rouge">@FBOption</code> wrapper will be decoded with its default value:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="o">&gt;</span> fbrepeat <span class="nt">--requiredPhrase</span> bonjour
bonjour
hello
bonjour
hello</code></pre></figure>

<p>The decoding is fully functional!</p>

<p>Let’s implement the final feature: generating a help description when requested.</p>

<h2 id="generating-command-help">Generating command help</h2>

<p>Thanks to the mirror inspection already in place, it will be easy. We just have to add some final touches to our API.</p>

<p>We add a <code class="language-plaintext highlighter-rouge">FBCommandConfiguration</code> structure so the clients can provide a description of their commands:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">public</span> <span class="kd">struct</span> <span class="kt">FBCommandConfiguration</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="k">let</span> <span class="nv">usage</span><span class="p">:</span> <span class="kt">String</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">usage</span><span class="p">:</span> <span class="kt">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">usage</span> <span class="o">=</span> <span class="n">usage</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">protocol</span> <span class="kt">FBParsableCommand</span><span class="p">:</span> <span class="kt">Decodable</span> <span class="p">{</span>

    <span class="kd">static</span> <span class="k">var</span> <span class="nv">configuration</span><span class="p">:</span> <span class="kt">FBParsableCommandConfiguration</span> <span class="p">{</span> <span class="k">get</span> <span class="p">}</span>

    <span class="nf">init</span><span class="p">()</span>
    <span class="kd">func</span> <span class="nf">run</span><span class="p">()</span> <span class="k">throws</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">extension</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>

    <span class="kd">static</span> <span class="k">var</span> <span class="nv">configuration</span><span class="p">:</span> <span class="kt">FBParsableCommandConfiguration</span> <span class="p">{</span>
        <span class="kt">FBParsableCommandConfiguration</span><span class="p">(</span>
            <span class="nv">name</span><span class="p">:</span> <span class="kt">String</span><span class="p">(</span><span class="nv">describing</span><span class="p">:</span> <span class="k">Self</span><span class="o">.</span><span class="k">self</span><span class="p">)</span><span class="o">.</span><span class="nf">lowercased</span><span class="p">(),</span>
            <span class="nv">usage</span><span class="p">:</span> <span class="s">""</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And a <code class="language-plaintext highlighter-rouge">help</code> parameter in each argument:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">FBOptionDefinition</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">isOptional</span><span class="p">:</span> <span class="kt">Bool</span>
    <span class="k">let</span> <span class="nv">defaultValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
    <span class="k">let</span> <span class="nv">help</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span>
<span class="p">}</span>

<span class="kd">extension</span> <span class="kt">FBOption</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">initialValue</span><span class="p">:</span> <span class="kt">String</span><span class="p">,</span> <span class="nv">help</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">definition</span><span class="p">(</span><span class="kt">FBOptionDefinition</span><span class="p">(</span><span class="nv">isOptional</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="n">defaultValue</span><span class="p">:</span> <span class="n">initialValue</span><span class="p">,</span> <span class="nv">help</span><span class="p">:</span> <span class="n">help</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="nf">init</span><span class="p">(</span><span class="nv">help</span><span class="p">:</span> <span class="kt">String</span><span class="p">?</span> <span class="o">=</span> <span class="kc">nil</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="o">.</span><span class="nf">definition</span><span class="p">(</span><span class="kt">FBOptionDefinition</span><span class="p">(</span><span class="nv">isOptional</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="n">defaultValue</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span> <span class="nv">help</span><span class="p">:</span> <span class="n">help</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Based on the static definition of a command, we can now easily generate a detailed error anytime we catch a help argument:</p>

<figure class="highlight"><pre><code class="language-swift" data-lang="swift"><span class="kd">struct</span> <span class="kt">HelpError</span><span class="p">:</span> <span class="kt">LocalizedError</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">localizedDescription</span><span class="p">:</span> <span class="kt">String</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">HelpGenerator</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">description</span><span class="p">:</span> <span class="kt">String</span>

    <span class="nf">init</span><span class="p">(</span><span class="n">_</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">FBParsableCommand</span><span class="o">.</span><span class="k">Type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">var</span> <span class="nv">description</span> <span class="o">=</span> <span class="s">""</span>
        <span class="n">description</span> <span class="o">+=</span> <span class="n">command</span><span class="o">.</span><span class="n">configuration</span><span class="o">.</span><span class="n">name</span>
        <span class="n">description</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">command</span><span class="o">.</span><span class="n">configuration</span><span class="o">.</span><span class="n">usage</span><span class="o">.</span><span class="n">isEmpty</span> <span class="p">{</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="n">command</span><span class="o">.</span><span class="n">configuration</span><span class="o">.</span><span class="n">usage</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">definition</span><span class="p">)</span> <span class="k">in</span> <span class="n">command</span><span class="o">.</span><span class="nf">argumentDefinitions</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="s">"--"</span> <span class="o">+</span> <span class="n">key</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">help</span> <span class="o">=</span> <span class="n">definition</span><span class="o">.</span><span class="n">help</span> <span class="p">{</span>
                <span class="n">description</span> <span class="o">+=</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">help</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">definition</span><span class="o">.</span><span class="n">isOptional</span> <span class="p">{</span>
                <span class="n">description</span> <span class="o">+=</span> <span class="s">" (optional)"</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nv">value</span> <span class="o">=</span> <span class="n">definition</span><span class="o">.</span><span class="n">defaultValue</span> <span class="p">{</span>
                <span class="n">description</span> <span class="o">+=</span> <span class="s">" (default </span><span class="se">\(</span><span class="n">value</span><span class="se">)</span><span class="s">)"</span>
            <span class="p">}</span>
            <span class="n">description</span> <span class="o">+=</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">FBCommandParser</span> <span class="p">{</span>

    <span class="k">let</span> <span class="nv">command</span><span class="p">:</span> <span class="kt">FBParsableCommand</span><span class="o">.</span><span class="k">Type</span>

    <span class="kd">func</span> <span class="nf">parse</span><span class="p">(</span><span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="k">throws</span> <span class="o">-&gt;</span> <span class="kt">FBParsableCommand</span> <span class="p">{</span>
        <span class="k">try</span> <span class="nf">checkForHelp</span><span class="p">(</span><span class="nv">in</span><span class="p">:</span> <span class="n">arguments</span><span class="p">)</span>
        <span class="c1">// ...</span>
        <span class="k">return</span> <span class="k">try</span> <span class="n">command</span><span class="o">.</span><span class="nf">init</span><span class="p">(</span><span class="nv">from</span><span class="p">:</span> <span class="n">decoder</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// ...</span>

    <span class="kd">private</span> <span class="kd">func</span> <span class="nf">checkForHelp</span><span class="p">(</span><span class="k">in</span> <span class="nv">arguments</span><span class="p">:</span> <span class="p">[</span><span class="kt">String</span><span class="p">])</span> <span class="k">throws</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nv">helpIndicators</span> <span class="o">=</span> <span class="p">[</span><span class="s">"-h"</span><span class="p">,</span> <span class="s">"--help"</span><span class="p">,</span> <span class="s">"help"</span><span class="p">]</span>
        <span class="k">let</span> <span class="nv">requestsHelp</span> <span class="o">=</span> <span class="n">helpIndicators</span><span class="o">.</span><span class="n">contains</span> <span class="p">{</span> <span class="n">indicator</span> <span class="k">in</span> <span class="n">arguments</span><span class="o">.</span><span class="nf">contains</span><span class="p">(</span><span class="n">indicator</span><span class="p">)</span> <span class="p">}</span>
        <span class="k">if</span> <span class="n">requestsHelp</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="kt">HelpError</span><span class="p">(</span><span class="nv">localizedDescription</span><span class="p">:</span> <span class="kt">HelpGenerator</span><span class="p">(</span><span class="n">command</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>And here we go! <code class="language-plaintext highlighter-rouge">FBSwiftArgumentParser</code> is able to generate a description of our command when a help option is specified:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="o">&gt;</span> fbrepeat <span class="nt">--help</span>
fbrepeat
<span class="nt">--optionalPhrase</span> <span class="o">(</span>optional<span class="o">)</span> <span class="o">(</span>default Hello<span class="o">)</span>
<span class="nt">--requiredPhrase</span></code></pre></figure>

<h2 id="the-drawback-of-the-swiftparserargument-implementation">The drawback of the SwiftParserArgument implementation</h2>

<p>Our basic version of <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> is small but it highlighted the main key tricks to create such a straightforward Swift library. Apple used a clever interlacing of operations executed at both compilation time and runtime.</p>

<p>At compilation time, all the command decoding code is generated on the client side thanks to the automatic conformance to <code class="language-plaintext highlighter-rouge">Decodable</code>. At runtime, <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> parses the static definition of each command and adapts the decoding strategy consequently. This last step is permitted by an extended usage of property wrappers: it allows Apple to encapsulate and inject logic right inside the client objects declaration. I really liked it.</p>

<p>However, to use the API of <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code>, clients have to follow an unusual list of agreements to ensure the program runs smoothly:</p>

<ul>
  <li>All the properties of a command have to be property wrappers provided by the library</li>
  <li>We must not override the default decoding behavior of the commands</li>
  <li>We must not instantiate commands ourself</li>
</ul>

<p>Such agreements can not be guaranteed by the Swift compiler. In fact, <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> counts <a href="https://github.com/apple/swift-argument-parser/search?q=fatalError">more than twenty fatalError</a> in its codebase. That is more than twenty manual checks that will lead to a crash if you are not respecting the usage contract.</p>

<p>That is why its implementation is hard to understand. In a regular codebase, targetting a production environment, we prefer to rely on the Swift compiler and therefore stay in the arguably safer environment it creates for us even if it means a more verbose code.</p>

<h2 id="a-swift-mod">A Swift mod</h2>

<p>With <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code>, Apple obviously made a tradeoff and decided that straightforwardness takes precedence over safety when writing CLI tools.</p>

<p>The fact that <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> will always be at the top of any programming stack surely influenced the decision.</p>

<p>It reminds me of <code class="language-plaintext highlighter-rouge">SwiftUI</code>. It has a beautiful Swift <a href="https://developer.apple.com/documentation/swiftui/">API</a> but it hides a lot of <a href="https://steipete.com/posts/state-of-swiftui/">unexpected behaviors</a>.</p>

<p>Like <code class="language-plaintext highlighter-rouge">SwiftUI</code>, <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> adds its own programming paradigm on top of Swift. By establishing rules that go way beyond traditional Swift library usage restrictions, like “commands should not use regular properties”, it extends the language itself, creating sort of a <a href="https://en.wikipedia.org/wiki/Video_game_modding">mod</a> of Swift and raising our code to new heights.</p>

<p>Of course, as the Swift compiler only knows Swift principles, those libraries have to validate their own rules at runtime with technics using metaprogramming as reflection. It inevitably leads to unsafe misuses.</p>

<p>In 2021, Apple had to <a href="https://developer.apple.com/videos/play/wwdc2021/10022/">demystify SwiftUI</a>. By revealing a bit of the SwiftUI implementation, Apple somehow agreed its usage of Swift can be confusing. We actually could not write such libraries using regular Swift - at least, using Swift as Apple wants us to use it, in a safe manner.</p>

<p>Still, chances are, those libraries are pioneers in the language features development rather than classic unsafe implementations. I will be not be suprised to see new Swift mods from Apple in the future.</p>

<p>As a side note, it is interesting to see how, after putting so much effort in building a safe language, Apple allows itself to bypass some of the compiler checks and write “flexible” Swift code, close to <a href="https://en.wikipedia.org/wiki/Objective-C#Dynamic_typing">the good old dynamic typing of Objective-C</a>.</p>

<h2 id="whats-next">What’s next?</h2>

<p>You can find all the code in a <a href="https://github.com/gaetanzanella/FBArgumentParser/tree/v1">dedicated repository</a> alongside a more <a href="https://github.com/gaetanzanella/FBArgumentParser/tree/v2">detailed version</a> of it.</p>

<p>I discovered <code class="language-plaintext highlighter-rouge">SwiftArgumentParser</code> when developing <a href="https://github.com/faberNovel/xcresource-cli">xcresource</a>. You can take a look at it! It aims to facilitate downloading Xcode templates or snippets from git repositories.</p>

<p>Thanks for reading!</p>

</div>



<div class="pagination">
  
  
    <a href="/2021-07-22/enhance-xcode-snippets-using-git" class="right arrow">Next article &#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>
    </main>

    <footer>
  <div class="container">
    <div class="footer-row">
      <div class="contact-links">
        <ul>
          <li><a>gaetan.zanella@fabernovel.com</a></li>
        </ul>
      </div>
    </div>

    <div class="footer-row">
      <div class="social-links">
        <ul class="social-media-list"><li><a rel="me" href="https://github.com/gaetanzanella" title="gaetanzanella"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/gaetanzanella" title="gaetanzanella"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
      </div>
    </div>
  </div>
</footer>

  </body>
</html>
